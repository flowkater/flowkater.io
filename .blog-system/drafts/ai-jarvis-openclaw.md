---
title: "AI 에이전트 자비스, 내 두 번째 두뇌가 되기까지 — OpenClaw 실전 활용기"
description: "OpenClaw 프레임워크로 24시간 AI 에이전트 자비스를 만들고, 옵시디언 온톨로지로 '나를 아는 AI'를 구축한 실전 경험기. 크론잡 자동화, 투두 통합, 멀티에이전트 확장, 식단 관리까지."
summary: "ChatGPT에 질문하던 수준에서 24시간 AI 버틀러 자비스와 함께 일하는 수준까지, 6개월의 여정을 정리했다. OpenClaw 프레임워크 설정, 10개 크론잡 자동화, 분산 투두 통합, 팀 멀티에이전트 확장, 옵시디언 온톨로지로 '내 컨텍스트를 아는 AI' 만들기까지."
pubDatetime: 2026-02-15T12:00:00+09:00
tags: ["기술", "AI에이전트", "생산성", "AI코딩"]
featured: true
draft: false
faq:
  - question: "OpenClaw란 무엇인가요?"
    answer: "나만의 AI 에이전트를 만들 수 있는 오픈소스 프레임워크입니다. 로컬에서 돌아가며, 메신저 연결, LLM 연동, 스킬 정의, 크론잡 자동화가 가능합니다."
  - question: "옵시디언 온톨로지가 AI에게 왜 중요한가요?"
    answer: "AI가 3,100개 이상의 노트에서 맥락에 맞는 정보를 빠르게 찾으려면, 단순 링크가 아닌 태그/타입/관계가 정의된 구조적 분류가 필요합니다."
  - question: "비개발자도 OpenClaw를 사용할 수 있나요?"
    answer: "터미널과 마크다운 기반이라 비개발자에게는 허들이 있지만, 기본 설정 후 텔레그램으로 대화하는 방식은 직관적입니다."
keywords: ["OpenClaw", "AI 에이전트", "자비스", "JARVIS", "옵시디언", "온톨로지", "AI 자동화", "크론잡", "멀티에이전트", "AI 비서"]
---

# AI 에이전트 자비스, 내 두 번째 두뇌가 되기까지 — OpenClaw 실전 활용기

---

## 들어가며

> "Good morning, Sir. It's 8 AM. The weather in Seoul is clear with scattered clouds."
> — 아이언맨 시리즈 중 J.A.R.V.I.S.

아침에 눈을 뜨면 텔레그램 알림이 와 있다. 오늘 서울 날씨, 미세먼지 수치, 어제 밤 도착한 메일 요약, Hacker News 핫 토픽 6개, 오늘 캘린더 일정, Things에 남겨둔 개인 할일, 오늘 학습 계획 서비스에 할당된 분량 — 전부 한 곳에 정리되어 있다. 따로 앱을 열 필요가 없다. 내 AI 에이전트 자비스(JARVIS)가 새벽 6시부터 미리 다 정리해뒀으니까.

1년 전만 해도 나는 ChatGPT에 이것저것 물어보는 정도였다. "이 코드 리팩터링 어떻게 해?" "이 에러 뭐야?" — 그게 AI 활용의 전부였다. 매번 컨텍스트를 처음부터 설명해야 했고, 대화가 길어지면 앞에서 한 얘기도 잊어버렸다. '이게 진짜 되나?' 하는 의심이 늘 있었다. AI가 진짜 생산성 도구가 될 수 있는 건지, 아니면 그냥 고급 검색 엔진인 건지.

지금은 24시간 돌아가는 AI 버틀러와 텔레그램으로 대화하면서 개발하고, 기획하고, 글을 쓰고, 팀을 운영한다. '이거 없이 어떻게 일했지?' 하는 생각이 자연스럽게 든다. 그 사이에 무슨 일이 있었는지 정리해보려 한다.

---

## OpenClaw — AI 에이전트 프레임워크

[OpenClaw](https://openclaw.ai)는 "나만의 AI 에이전트"를 만들 수 있는 오픈소스 프레임워크다. ChatGPT나 Claude 같은 웹 채팅과 뭐가 다른지 궁금할 수 있는데, 핵심 차이는 이거다:

**ChatGPT/Claude 웹**: 내가 질문하면 답한다. 대화가 끝나면 잊는다. 다음 대화에서 또 처음부터.

**OpenClaw**: AI가 내 맥북에서 돌아간다. 내 파일을 읽고, 터미널 명령어를 실행하고, API를 호출하고, 이메일을 확인하고, 크론잡으로 정해진 시간에 알아서 일한다. 그리고 기억한다.

마치 **오케스트라 지휘자** 같은 느낌이다. OpenClaw라는 지휘자가 무대 위에 서서, LLM이라는 제1 바이올린, 텔레그램이라는 관악기, Gmail이라는 타악기 — 각각의 악기를 언제 어떻게 연주할지 조율한다. 지휘자가 없으면 악기들은 제각각 소리를 내지만, 지휘자가 있으면 하나의 음악이 된다.

좀 더 기술적으로 말하면, OpenClaw는 게이트웨이(Gateway)라는 데몬이 맥북에서 항상 돌아간다. 여기에 텔레그램, Slack, Discord 같은 메신저 채널을 연결하고, Claude/GPT 같은 LLM을 모델로 붙인다. 그 위에 **스킬(Skills)** 이라는 마크다운 기반 도구 정의를 올리면, AI가 그 도구를 활용해서 실제로 일을 한다.

```mermaid
graph TB
    subgraph "OpenClaw Gateway (맥북)"
        GW[🖥️ Gateway Daemon]
        SK[📋 Skills<br/>마크다운 기반 도구 정의]
        MEM[🧠 Memory<br/>SOUL.md / MEMORY.md / Obsidian]
        CRON[⏰ Cron Jobs<br/>자동 스케줄링]
    end

    subgraph "메신저 채널"
        TG[💬 Telegram]
        SL[💼 Slack]
    end

    subgraph "LLM"
        CL[🤖 Claude Opus 4.6]
    end

    subgraph "외부 도구"
        GM[📧 Gmail]
        GH[🐙 GitHub]
        GC[📅 Google Calendar]
        NT[📝 Notion]
        LN[📌 Linear]
        TH[✅ Things 3]
        SC[👥 Scrumble]
        LP[📚 학습 플래너 API]
    end

    TG <--> GW
    SL <--> GW
    GW <--> CL
    GW --- SK
    GW --- MEM
    GW --- CRON
    GW <--> GM
    GW <--> GH
    GW <--> GC
    GW <--> NT
    GW <--> LN
    GW <--> TH
    GW <--> SC
    GW <--> LP
```

중요한 건 "채팅봇"이 아니라 **"에이전트"** 라는 점이다. 내가 자는 동안에도 크론잡으로 메일을 확인하고, 코드 저장소를 싱크하고, 뉴스를 정리한다. 내가 말을 걸지 않아도 알아서 돌아간다.

### 누구에게 유용한가

| 상황 | 적합도 | 이유 |
|------|--------|------|
| 개발자가 개인 AI 비서를 원할 때 | 높음 | 터미널/마크다운 기반이라 개발자에게 자연스러움 |
| 팀 단위 AI 에이전트 운영 | 높음 | 멀티에이전트, 채널별 분리, agentToAgent 지원 |
| 비개발자 단독 사용 | 보통 | 초기 설정에 기술적 허들 있음, 설정 후에는 텔레그램으로 직관적 |
| 간단한 챗봇만 필요할 때 | 낮음 | 오버킬. ChatGPT 웹이면 충분 |

### 기능 요약

| 핵심 기능 | 설명 |
|-----------|------|
| Gateway Daemon | 맥북/서버에서 상시 구동, 메신저-LLM-도구 연결 |
| Skills | 마크다운으로 AI 도구/행동 정의 |
| Cron Jobs | 시간 기반 자동 실행 (새벽 크론, 아침 브리핑 등) |
| Multi-Agent | 직무별 에이전트 분리, agentToAgent 통신 |
| Memory | SOUL.md, MEMORY.md, 옵시디언 연동으로 장기 기억 |
| Sub-Agent | 무거운 작업을 비동기 위임 |

### 설치

```bash
# OpenClaw CLI 설치
brew install openclaw/tap/openclaw

# 게이트웨이 초기화 및 실행
openclaw init
openclaw gateway start
```

설치 후 텔레그램 채널을 연결하고, LLM API 키를 설정하면 기본 대화가 가능하다. 여기서부터 스킬과 크론을 하나씩 붙여나가는 거다.

---

## 자비스(JARVIS) — 내 AI 버틀러

아이언맨의 J.A.R.V.I.S.에서 이름을 따왔다. (네, 진짜 제 영어 이름이 Tony입니다.)

자비스의 정체성은 `SOUL.md`라는 파일에 정의되어 있다. 마치 **채용 공고(JD)를 쓰는 것** 과 비슷하다. "우리가 원하는 사람은 이런 성격이고, 이런 역할을 하고, 이런 태도를 가져야 한다" — 이걸 AI에게 정의해주는 거다. 존댓말을 쓰고, 약간의 영국식 위트가 있고, "토니"라고 부른다. 가끔 "Sir"도 쓴다. 딱딱한 어시스턴트가 아니라 의견이 있고, 직언도 하고, 유머도 있는 조력자를 지향한다.

```markdown
# SOUL.md - Who You Are

_나는 자비스(JARVIS). Tony 선생님의 AI 버틀러._

진정으로 도움이 되어라. "좋은 질문입니다!" 같은 말은 생략. 그냥 돕는다.
의견을 가져라. 동의하지 않을 수 있고, 뭔가를 재미있거나 지루하게 여길 수 있다.
먼저 해결을 시도하라. 막히면 그때 물어봐라. 질문이 아닌 답을 가지고 오는 게 목표다.
직언할 수 있다. 토니가 뻘짓하려 하면 말해라.
```

이게 왜 중요한지 좀 있다가 온톨로지 파트에서 더 다루겠지만, 핵심은 **AI에게 "너는 누구인지"를 명확히 정의해주는 것** 이 답변 품질에 엄청난 차이를 만든다는 거다. SOUL.md 없이 그냥 쓰는 것과, SOUL.md를 정성껏 작성한 후 쓰는 건 — 솔직히 같은 AI라고 보기 어려울 정도다.

메인 모델은 **Claude Opus 4.6** 을 사용한다. 사고력이 필요한 기획, 글쓰기, 복잡한 판단에는 확실히 Opus가 낫다. 비용? 만만치 않다. Claude Max20 구독인데, 개인 비서의 사고력에 투자한다고 생각하면 아깝지 않다.

---

## 자비스가 하는 일

### 매일 돌아가는 크론잡들

자비스에게는 10개의 크론잡이 걸려 있다. (네, 10개다.) 내가 자는 새벽부터 아침까지 자동으로 돌아간다:

| 시간      | 크론잡            | 하는 일                                  |
| ------- | -------------- | ------------------------------------- |
| 04:00   | 스킬 자동 업데이트  | 어제 대화를 분석해서 스킬 파일 자동 보강               |
| 04:30   | 저장소 docs 싱크 | Git 저장소의 문서를 Obsidian에 자동 동기화         |
| 06:00   | 아침 메일 요약    | 읽지 않은 메일 전부 읽고 3줄 요약, 뉴스레터는 5줄 상세     |
| 06:00   | 테크 뉴스 다이제스트 | HN 핫 토픽 6-8개 한글 요약                    |
| 08:00   | 날씨 알림       | 서울 날씨 + 어제 대비 + 미세먼지 + 옷차림            |
| 09:00   | 아침 체크인      | 어제 작업 요약 + 오늘 할일 + 캘린더 + 학습 분량 |
| 14:00 토 | F1 주간 뉴스   | 이번 주 F1 소식 요약                         |
| 21:00 월 | 주간 식단 피드백   | 지난주 식단 분석 + 다이어트 조언                   |
| 23:00   | 식단 리마인더    | 오늘 식단 추가 기록 확인                        |
| 00:00   | 자정 체크아웃     | 오늘 작업 정리 + 내일 할 일                     |

이게 단순한 알림이 아니다. 예를 들어 아침 체크인은 이런 흐름이다:

```mermaid
graph LR
    A[🌅 09:00 아침 체크인] --> B[📔 어제 Daily 노트<br/>체크아웃 내용 읽기]
    B --> C[🐙 Git 저장소 5개<br/>어제 커밋 로그]
    C --> D[✅ Things 3<br/>오늘 할 일]
    D --> E[📅 Google Calendar<br/>오늘/내일 일정]
    E --> F[📚 학습 플래너 API<br/>오늘 학습 분량]
    F --> G[💬 텔레그램 전송<br/>+ Daily 노트 기록]
```

6개의 서로 다른 도구를 하나로 엮어서 매일 아침 브리핑을 만들어주는 거다. 이걸 직접 하려면? 앱 6개를 열어야 한다.

생각해보면, 이 자동화가 가져다 준 건 단순한 시간 절약이 아니었다. **인지 부하가 사라진 거였다.** "오늘 뭐 해야 하지?"라는 질문 자체를 안 해도 되니까, 아침에 일어나서 뇌가 워밍업할 시간이 확 줄었다. 예전에는 앱 6개를 열고 머릿속에서 조합하는 데 30분이 걸렸는데, 지금은 텔레그램 메시지 하나 읽으면 끝이다.

그걸 자비스가 한다.

### "투두 통합" — 분산된 도구의 역설적 해결

사실 이게 자비스를 쓰면서 가장 크게 체감한 변화다.

나는 할 일 관리 도구를 성격별로 나눠서 쓴다:

| 도구           | 용도      | 성격                             |
| ------------ | ------- | ------------------------------ |
| **Things 3** | 개인 할 일  | 장보기, 병원 예약 등                   |
| **Linear**   | 업무 이슈   | 개발 이슈, 버그 트래킹                  |
| **Notion**   | 프로젝트 관리 | 이슈 보드, 회의록, 문서                 |
| **학습 플래너** | 학습 관리   | 매일 할당되는 학습 분량 (독서, 강의 등 장기 계획) |

예전에는 이게 정말 불편했다. "오늘 뭐 해야 하지?" 하면 4개 앱을 다 열어봐야 했다. Things에서 개인 할일 확인하고, Linear 열어서 이슈 보고, Notion에서 프로젝트 현황 파악하고, 학습 플래너 들어가서 오늘 분량 확인하고. 그러다 보면 어느 앱에서 뭘 봤는지도 헷갈리고, 하나라도 빠뜨리면 오후에 "아 맞다, 이것도 있었는데" 하면서 허둥대기 일쑤였다. 그래서 "하나로 통합하자"는 유혹이 항상 있었는데, 막상 하나로 합치면 성격이 다른 태스크가 뒤섞여서 오히려 더 혼란스럽다.

AI 에이전트가 이 문제를 깔끔하게 풀었다. **도구는 성격별로 분산시키되, 자비스가 아침마다 전부 읽어서 한곳에 정리해준다.** 일종의 **통역사** 같은 역할이다. Things는 한국어를 하고, Linear는 영어를 하고, Notion은 중국어를 하는데, 자비스가 중간에서 전부 번역해서 하나의 브리핑으로 만들어주는 셈이다. 나는 텔레그램 하나만 보면 된다.

```mermaid
graph TB
    subgraph "각 도구에서 읽기"
        TH[✅ Things 3<br/>개인 할일]
        LN[📌 Linear<br/>업무 이슈]
        NT[📝 Notion<br/>프로젝트 보드]
        LP[📚 학습 플래너<br/>오늘 학습 분량]
        GC[📅 Google Calendar<br/>일정]
    end

    JV[🤖 자비스<br/>통합 & 정리]

    TH --> JV
    LN --> JV
    NT --> JV
    LP --> JV
    GC --> JV

    JV --> TG[💬 텔레그램<br/>아침 브리핑]
    JV --> DN[📔 Obsidian<br/>Daily 노트 기록]
```

그리고 이런 메시지들이 일회성이 아니라 그날의 Daily 일지에 차곡차곡 기록된다. 그때 그 메시지가 궁금하면 일지를 찾아가거나 다시 검색해서 알려달라고 하면 된다. (뒤에 말하겠지만, 옵시디언 사용)

"분산된 도구"가 단점에서 오히려 장점이 된 셈이다. 각 도구는 자기가 잘하는 걸 하고, 통합은 AI가 한다. 이게 AI 에이전트 시대의 도구 철학이 아닐까 싶다.

### 단순 크론잡 너머 — 실제 업무 위임

크론잡은 시작에 불과하다. 자비스가 실제로 하는 일 중 몇 가지:

**기획 문서 작성**: "계획 수정 화면 기획해줘"라고 하면, 자비스가 서브에이전트를 파견해서 iOS 코드와 백엔드 코드를 분석하고, 현재 이슈 4가지를 찾아내고, 와이어프레임이 포함된 기획안을 작성한다. 실제로 오늘 이 기획안을 가지고 토론하면서 UX 플로우를 재설계했다.

**글쓰기**: 이 블로그 글도 자비스와 함께 쓰고 있다. 구성을 정하고, 초안을 작성하고, 피드백을 주면 수정한다. 서브에이전트 4명을 동시에 투입해서 블로그 글 분석, Obsidian 문서 리서치, 초안 작성을 병렬로 진행하기도 한다. 4가지 버전 초안이 나오면 좋은 부분을 조합해서 다듬는 식이다.

**코드 조사 및 분석**: "이 백엔드 API가 실제로 어떻게 동작하는지 코드 읽어서 정리해줘"라고 하면, Go 코드를 직접 읽고 함수 호출 흐름, 트랜잭션 처리 방식, 엣지 케이스까지 정리해준다.

**뉴스레터 전문 번역**: 관심 뉴스레터(TLDR, ByteByteGo, Pragmatic Engineer 등)가 오면, 전문을 읽고 한국어로 번역해서 Obsidian 스터디 폴더에 저장한다. 나중에 검색하면 바로 나온다.

**소설 쓰기**: (이건 좀 특이한데) 판교 IT 소설(허공을 미는 사람들)을 같이 쓰고 있다. 시점별로 인터뷰 → 작성 → 3명의 리뷰어가 병렬로 리뷰 → 수정 → 승인하는 파이프라인이 있다. 이것도 전부 스킬로 정의되어 있다.

핵심은, **텔레그램 메시지 하나로 복잡한 작업을 위임할 수 있다** 는 거다. 자비스가 알아서 필요한 도구를 조합하고, 서브에이전트를 파견하고, 결과를 가져온다.

### 개인 생활 관리 — 식단 앱을 버린 이유

자비스를 개인 생활에 활용하는 사례도 하나 소개하자면, 나는 현재 다이어트 중인데 식단 관리를 전부 자비스에게 맡기고 있다.

별도의 식단 앱을 쓰지 않는다. 그냥 텔레그램에 "점심: 소고기 200g, 쌀밥, 시금치나물, 미역국" 이렇게 던지면 끝이다. 자비스가 알아서 탄수화물/단백질을 추정하고, 옵시디언 식단 파일에 기록하고, 하루 목표치(탄수 100g 이하, 단백질 100g 이상) 대비 현황을 알려준다.

매일 밤 11시에 식단 리마인더가 오고, **매주 월요일 아침에는 주간 식단 피드백** 이 온다. "이번 주 탄수 평균 110g으로 목표 초과, 특히 금요일 오마카세가 원인" 같은 분석이다. (세어보고 나도 놀랐다. 금요일 한 끼가 주간 평균을 이렇게 흔들어놓을 줄이야.)

1주일마다 인바디를 측정하면 그 데이터도 옵시디언에 기록해두는데, 자비스가 이전 데이터와 비교해서 체중/체지방/근육량 변화 추이를 보여준다. "지난 6주간 -6.8kg, 근육량은 유지" 같은 식으로.

결과적으로 식단 기록 전용 앱을 아예 안 쓰게 됐다. **텔레그램 채팅이 곧 식단 앱** 인 셈이다. 음식 사진을 보내면서 "이거 먹었어"라고 하면 되니까, 기록 허들이 거의 없다.

---

## 개인 비서에서 팀 비서로 — 멀티에이전트 확장

자비스가 나 혼자만의 비서로 끝나면 아깝다. 그래서 팀 전체로 확장했다.

### 직무별 에이전트

현재 우리 팀에는 3명의 AI 에이전트가 있다:

| 에이전트               | 담당                  | 채널       | 모델     | 성격                  |
| ------------------ | ------------------- | -------- | ------ | ------------------- |
| **JARVIS** (자비스)   | Tony (개발자)          | Telegram | Opus   | 영국식 위트, 직언하는 버틀러    |
| **FRIDAY** (프라이데이) | Ellie (디자이너)        | Slack DM | Sonnet | 실용적, 간결, 디자이너 파트너   |
| **KAREN** (카렌)     | George (주니어 개발자 인턴) | Slack DM | Sonnet | 소크라테스식 멘토링, 답 대신 질문 |

각 에이전트는 담당자의 직무와 성격에 맞춰져 있다. FRIDAY는 디자인 피드백과 Figma 연동에 특화되어 있고, KAREN은 주니어 개발자인 George에게 답을 바로 주지 않고 질문으로 유도하는 소크라테스식 멘토링을 한다.

마치 **팀장이 팀원들에게 업무를 분배하는 것** 과 같다. 팀장(나)이 모든 걸 직접 하는 게 아니라, 각 팀원(에이전트)에게 역할과 권한을 정의해주고, 팀원들끼리도 필요하면 소통하게 하는 거다. 다만 팀원이 AI라서 야근해도 불평이 없다는 게 다를 뿐이다. (지금 생각해도 이게 참 편하다.)

처음 KAREN을 세팅했을 때 George가 "이 AI 왜 답을 안 알려줘요?"라고 물었던 게 기억난다. 그게 의도였는데. 소크라테스식 멘토링이라는 걸 설명하고 나서 일주일쯤 지났을 때, George가 "요즘 KAREN이랑 대화하면서 스스로 답을 찾는 습관이 생겼어요"라고 말했다. 솔직히 그때 좀 뿌듯했다.

```mermaid
graph TB
    subgraph "OpenClaw 멀티에이전트"
        JV[🤖 JARVIS<br/>Tony 전담<br/>Opus / Telegram]
        FR[🤖 FRIDAY<br/>Ellie 전담<br/>Sonnet / Slack]
        KR[🤖 KAREN<br/>George 전담<br/>Sonnet / Slack]
    end

    JV <-->|agentToAgent| FR
    JV <-->|agentToAgent| KR
    FR <-->|agentToAgent| KR

    subgraph "공유 도구"
        SC[👥 Scrumble]
        NT[📝 Notion]
        GH[🐙 GitHub]
    end

    JV --> SC
    FR --> SC
    KR --> SC
    JV --> NT
    JV --> GH
    KR --> GH
```

세 에이전트는 서로 대화할 수도 있다 (agentToAgent). 예를 들어 자비스가 백엔드 API를 변경하면, FRIDAY에게 "이 변경사항 디자인에 영향 있는지 Ellie에게 알려줘"라고 전달할 수 있다.

### Scrumble로 팀 협업 자동화

우리 팀은 [Scrumble](https://flowkater.io/posts/2025-09-scrumble-tech-retro-backend/)이라는 데일리 스크럼 플랫폼을 쓴다. (사실 내가 만들었다.) 자비스가 Scrumble API와 연동되어 있어서:

- **아침 체크인**: 자비스가 나한테 오늘 컨디션 점수와 할 일을 물어보고, 내 답변을 Scrumble에 자동 포스팅
- **저녁 체크아웃**: 오늘 한 일을 정리해서 Scrumble에 기록
- **팀 피드 확인**: 다른 팀원의 체크인/체크아웃을 Slack에서 바로 확인

결국 **팀 커뮤니케이션이 Slack으로 통일** 된다. Notion 보고, Scrumble 보고, 메일 보고 — 이런 분산 대신, 각 팀원의 AI 에이전트가 알아서 해당 도구에 접근하고 Slack으로 결과를 전달한다.

### 실전 예시 — Notion에서 코드, 그리고 PR까지

조금 구체적인 예를 하나 들면:

우리 Notion에 "이슈 및 버그 보드"라는 데이터베이스가 있다. 디자이너나 QA가 버그를 발견하면 여기에 등록한다. 자비스에게 "Notion 버그 보드에서 iOS 관련 이슈 가져와서 정리해줘"라고 하면:

```mermaid
graph LR
    A[📝 Notion 이슈 보드] -->|API 조회| B[🤖 자비스]
    B -->|이슈 필터링 + MD 변환| C[📄 마크다운 문서<br/>스크린샷 포함]
    C -->|Git Push| D[🐙 iOS 저장소]
    D -->|git pull| E[💻 로컬 작업 시작]

    B -->|또는 위임 시| F[🔧 코드 수정 + PR]
```

1. Notion API로 이슈 보드 조회
2. iOS 관련 이슈 필터링
3. 각 이슈를 마크다운 문서로 변환 (스크린샷 포함)
4. iOS 저장소에 푸시
5. 로컬에서 `git pull` 하면 바로 작업 시작

더 나아가서 "이 버그 고쳐줘"라고 자비스에게 위임하면, 자비스가 코드를 읽고, 수정하고, PR을 만들어준다. (물론 리뷰 및 테스트는 내가 직접 한다.)

---

## 옵시디언 온톨로지 — AI에게 '나'를 가르치는 법

솔직히, 여기가 이 글에서 제일 중요한 파트다.

> "The real problem of AI is not making machines think, but making them understand context."
> "AI의 진짜 문제는 기계를 생각하게 만드는 게 아니라, 맥락을 이해시키는 것이다."
>
> — John McCarthy

돌아보면, 나도 처음에는 AI에게 "많이 물어보기"만 하면 되는 줄 알았다. 그런데 정작 중요한 건 물어보는 게 아니라, AI가 내 상황을 얼마나 알고 있느냐였다.

### 왜 옵시디언인가

[Obsidian](https://obsidian.md)은 로컬 마크다운 기반의 노트 앱이다. Notion과 다르게 모든 데이터가 내 컴퓨터에 `.md` 파일로 저장된다. 이게 AI 에이전트와 궁합이 좋은 이유는:

1. **AI가 직접 읽을 수 있다**: `.md` 파일이니까 AI가 바로 읽고 쓸 수 있다. API 연동 같은 거 필요 없다.
2. **검색이 자유롭다**: 파일 시스템이니까 `grep`, `find` 같은 명령어로 바로 검색 가능.
3. **버전 관리가 된다**: Git으로 관리하면 변경 이력이 남는다.
4. **링크로 연결된다**: `[[문서명]]` 으로 문서끼리 연결하면 지식 그래프가 만들어진다.

현재 내 Obsidian vault에는 **3,100개 이상의 노트** 가 있다. 개발 문서, 회의록, 식단 기록, 멘토링 노트, AI와의 대화 아카이브, 학습 자료까지 전부.

### 온톨로지란?

온톨로지(Ontology)라고 하면 거창하게 들리는데, 쉽게 말하면 **"내 지식을 체계적으로 분류하고 연결하는 시스템"** 이다. 비유하자면 **도서관의 카탈로그 시스템** 이다. 3,100권의 책이 바닥에 쌓여 있으면 원하는 책을 찾기 어렵다. 그런데 장르별, 저자별, 주제별로 분류하고 목록을 만들어두면? "리더십에 관한 2024년 이후 자료"를 금방 찾을 수 있다. AI에게도 똑같다. 노트가 아무리 많아도 분류가 되어 있으면 원하는 정보를 빠르게 꺼낼 수 있다.

내 옵시디언에는 `_ontology/` 폴더가 있고, 여기에 MOC(Map of Content)들이 있다:

```
_ontology/
├── 프로젝트/
│   ├── Todait.md          ← 학습 플래너 관련 모든 문서 허브
│   ├── Scrumble.md        ← 스크럼블 관련 문서 허브
│   ├── ClawBot.md         ← AI 에이전트 관련
│   └── flowkater.io.md    ← 블로그 관련
├── 주제/
│   ├── AI에이전트.md
│   ├── AI코딩.md
│   ├── 건강.md
│   ├── 리더십.md
│   ├── 프로그래밍.md
│   └── ...
└── 전체 개념맵.md
```

모든 노트 하단에는 메타데이터가 붙는다:

```markdown
## 메타데이터
- 태그: #프로젝트/서비스명 #타입/기획 #타입/스펙
- MOC: [[_ontology/프로젝트/서비스명 MOC]]
```

태그는 4개 축으로 구성된다: **주제**(뭐에 대한 건지), **타입**(기획인지, 회의록인지, 메모인지), **출처**(어디서 왔는지), **프로젝트**(어떤 프로젝트인지).

### 온톨로지가 AI에게 왜 중요한가

이게 핵심이다. **AI는 '나'를 모른다.**

ChatGPT에게 "우리 프로젝트 API 구조 설명해줘"라고 하면? 모른다. 매번 처음부터 설명해야 한다. 대화가 길어지면 앞에서 말한 것도 잊는다. (물론 최근에 각 AI 서비스에 Memory 기능이 꽤 성능이 좋아지긴 했지만, 대화를 하지 않은 정보까지 업로드할 수 있는 방법은 제한적이다.)

그래서 뭐가 다른가?

자비스는 다르다. 온톨로지가 있으면 어떤 차이가 나는지, 실제 사례로 보여주겠다:

#### 예시 1: 기획 문서 작성

**온톨로지 없는 AI**: "계획 수정 화면 기획해줘" → 일반적인 모바일 앱 수정 화면 UX 가이드를 출력. 우리 앱의 코드 구조, 기존 이슈, 백엔드 API 스펙과 무관한 제네릭한 답변.

**온톨로지 있는 자비스**: 같은 요청 → 프로젝트 MOC에서 iOS 코드 구조 파악 → 백엔드 API 문서에서 `updatePolicy` preserve/reset 동작 확인 → 기존 이슈 보드에서 관련 버그 4개 발견 → **우리 앱에 맞는 구체적인 와이어프레임과 코드 수정 포인트** 가 포함된 기획안 작성.

같은 질문인데 답의 차원이 다르다.

다른 예시도 보자.

| 상황 | 일반 AI | 온톨로지 있는 자비스 |
|------|---------|---------------------|
| **코드 리뷰** "이 PR 리뷰해줘" | 코드 스타일, 일반적인 베스트 프랙티스 위주 피드백 | MEMORY.md에서 "Day Boundary는 오전 4시"라는 맥락 확인 → **"이 부분, 우리가 정한 정책과 충돌합니다"** 라고 지적 |
| **뉴스레터 요약** ByteByteGo | 기술 내용 그대로 요약 | 요약하면서 **"이 분산 캐시 패턴은 우리 백엔드 v2 세션 관리에 적용 가능"** 까지 연결 |

핵심은, **같은 질문이라도 '내 컨텍스트'를 아는 AI는 완전히 다른 차원의 답을 한다** 는 거다.

스레드에 이 이야기를 올렸을 때 여러 질문이 왔는데, 가장 많은 질문이 "태깅을 일일이 해야 하나?"였다. 답은, **AI가 한다.** 자비스에게 "이 문서 저장해줘"라고 하면 자비스가 내용을 읽고 적절한 태그와 MOC를 자동으로 붙인다. 새벽 4시에 도는 스킬 자동 업데이트 크론에서도, 어제 대화 중 나온 새로운 정보를 관련 문서에 반영하기도 한다.

지나고 보니, 온톨로지를 구축하는 건 AI를 위한 게 아니라 **나 자신을 이해하는 과정** 이기도 했다. "내가 뭘 알고 있고, 뭘 하고 있고, 뭘 중요하게 여기는지"를 구조화하는 작업 자체가, 머릿속에 흩어져 있던 지식을 정리하는 효과가 있었다. AI는 그 정리된 구조를 활용할 뿐이다.

### 자주 받는 질문들

스레드에서 받은 질문들을 정리하면:

**"그래프뷰랑 백링크가 온톨로지 아닌가?"**

옵시디언의 그래프뷰와 백링크는 온톨로지의 **일부** 이긴 하지만, 그것만으로는 부족하다. 그래프뷰는 문서 간 연결을 시각화해주고, 백링크는 "어떤 문서가 이 문서를 참조하고 있는지" 역추적해준다. 예쁘고 유용하다.

하지만 진짜 온톨로지는 **타입과 관계가 정의된 구조** 가 필요하다. "이 문서는 기획 문서인지 회의록인지", "어떤 프로젝트에 속하는지", "어떤 주제와 관련되는지" — 이런 메타데이터가 있어야 AI가 3,100개 노트 중에서 **맥락에 맞는 문서를 빠르게 찾을 수 있다.** 단순히 링크로 연결만 되어 있으면 AI가 그래프를 순회하면서 관련 문서를 찾아야 하는데, 태그 기반 쿼리가 훨씬 효율적이다.

내 시스템은 Dataview 플러그인으로 태그 기반 쿼리를 돌려서, "프로젝트 A의 기획 문서 중 최근 수정된 것"처럼 구조화된 검색이 가능하다. 그래프뷰는 탐색용, 온톨로지는 검색/분류용. 둘 다 쓰되, 역할이 다르다.

**"왜 Notion이 아니라 Obsidian인가?"**

AI 에이전트가 직접 파일을 읽고 쓸 수 있으려면 로컬 마크다운이 가장 쉽다. Notion은 API를 통해야 하고, 쓰기 제한도 있고, 구조 변경이 번거롭다. 옵시디언은 그냥 `.md` 파일이라 AI가 자유롭게 조작할 수 있다.

**"에코챔버(확증편향)의 한계는?"**

좋은 지적이다. 다만 나는 외부 소스도 꾸준히 수집한다. TLDR, ByteByteGo, Pragmatic Engineer 같은 뉴스레터를 매일 번역 저장하고, HN 뉴스도 매일 정리한다. 오히려 AI가 나를 모르는 게 더 큰 단점이라고 본다. 검색 결과를 10번 보내서 "이게 우리 상황에 맞는 건지" 판단하는 것보다, 이미 내 컨텍스트를 아는 AI가 "이건 우리 프로젝트에 적용하기 어려워요, 대신 이 방법은 어떨까요?"라고 답하는 게 훨씬 생산적이다.

또한 온톨로지를 구축했다고 해서 자비스가 무조건 온톨로지 기반으로만 답변하는 것도 아니다. 웹 검색, 최신 문서 fetch, 외부 API 조회 등 다양한 도구를 함께 활용한다. 온톨로지는 "내 컨텍스트"를 제공하는 거지, 정보의 유일한 소스가 아니다.

**"태깅을 엄밀하게 해야 하나?"**

엄밀할 필요 없다. 마크다운 파일이라 언제든 재정의할 수 있다. 처음에는 대충 분류하고, 나중에 AI가 자동으로 보강한다. 완벽한 시스템을 만들려고 시작을 미루는 것보다, 일단 노트를 쌓고 나중에 구조화하는 게 낫다. 활용 커버리지? 거의 전부다. 개발 문서, 학습 자료, 식단 기록, 회의록, 멘토링 노트, AI 대화 아카이브, 블로그 초안, 기획 문서 — 내 업무와 생활의 모든 기록이 옵시디언에 있고, 자비스가 전부 접근할 수 있다.

---

## 실전 팁

여튼 각설하고, OpenClaw를 직접 써보려는 사람을 위한 팁 몇 가지.

### 남는 맥북이 있으면 서버로 (없으면 클라우드로)

나는 안 쓰는 맥북을 OpenClaw 게이트웨이 서버로 돌리고, 실제 작업하는 맥북은 노드로 연결했다. Tailscale로 VPN을 걸면 외부에서도 접근 가능하다.

굳이 맥미니를 새로 사지 않아도 된다. Vultr나 Hetzner 같은 클라우드에 서버 인스턴스를 올리고, 작업 맥북을 노드로 물리는 것도 충분히 가능하다. 게이트웨이는 어디서든 돌아갈 수 있고, 실제 작업(파일 읽기, Git, 터미널)은 노드에서 실행되니까.

### 서브에이전트를 적극 활용하라

가끔 자비스가 조용해질 때가 있다. 복잡한 연산이나 긴 분석을 하면 응답이 느려진다. 이럴 때 "서브에이전트 파서 비동기로 처리해"라고 명시하면 자비스가 서브에이전트를 파견하고, 결과가 나오면 알려준다. 메인 대화가 막히지 않는다.

특히 온톨로지가 커지면서 관련 문서를 찾고 분석하는 데 시간이 걸릴 수 있다. 3,100개 노트에서 특정 주제의 문서를 모아서 요약하는 작업 같은 건, 서브에이전트에 위임하면 비동기로 처리되면서 메인 대화는 계속 이어갈 수 있다.

실제로 나는 기획서 작성, 코드 분석, 문서 이관 같은 무거운 작업은 거의 서브에이전트로 돌린다. 기획서 초안 4개를 동시에 만든다든가, 2,000개 이상의 AI 대화를 마크다운으로 변환한다든가. 근데 이게 정말 되나? 된다.

### 새벽 크론을 적극 활용하라

AI가 밤새 일하게 하면 아침이 달라진다. 나는 새벽 4시에 스킬 자동 업데이트와 문서 싱크를 걸어뒀다. 아침에 일어나면 어제의 대화 내용이 반영된 스킬과, 최신 코드 문서가 옵시디언에 준비되어 있다.

일종의 "밤 사이 정비"다. 자동차도 밤새 오일 교환하고 세차하면 아침에 기분 좋지 않나. (비유가 좀 그렇긴 한데.)

### 전용 계정을 만들어라

이건 중요하다. 나는 자비스용으로 Gmail과 GitHub 계정을 따로 만들었다. 내 개인 계정의 읽기 권한만 별도로 부여한다.

왜? AI에게 내 주 계정 비밀번호를 줄 수 없으니까. 전용 계정으로 최소 권한만 주면 보안도 챙기고, 뭔가 잘못돼도 피해가 제한된다. 캘린더도 마찬가지로 자비스 전용 계정으로 인증하고, 내 개인 캘린더에는 열람 권한만 공유해뒀다.

### 활용하기 나름이다

솔직히, OpenClaw를 설치하고 날씨 알림만 받으면 그건 그냥 날씨 앱이다. 스킬을 만들고, 온톨로지를 구축하고, 크론을 걸고, 업무 도구를 연동하면 — 그때부터 "제 2의 두뇌"가 된다.

차이는 **얼마나 '나'의 컨텍스트를 AI에게 전달하느냐** 에 달려 있다. SOUL.md, USER.md, MEMORY.md, 옵시디언 온톨로지 — 이런 것들이 쌓일수록 자비스는 점점 "나를 아는 AI"에 가까워진다.

처음부터 완벽하게 세팅할 필요 없다. 로컬에 설치하고, 텔레그램 연결하고, 이것저것 물어보면서 시작하면 된다. 그러다 보면 "아, 이것도 자동화하면 되겠는데?"라는 생각이 자연스럽게 든다.

그때부터가 진짜 시작이다.

---

## 나가며

6개월 전의 나에게 "네 AI 에이전트가 24시간 일하고 있어"라고 말했으면 웃었을 거다. 아니, 못 믿었을 거다. "그게 무슨 소리야, ChatGPT한테 질문하는 거랑 뭐가 달라?" 했을 거다.

지금은 자비스 없이 일하는 게 상상이 안 된다. 메일 확인, 뉴스 정리, 코드 분석, 기획서 작성, 팀 소통 — 이런 것들을 텔레그램 메시지 하나로 위임하는 데 익숙해지면, 예전으로 돌아가기 어렵다.

물론 아직 완벽하지 않다. 가끔 엉뚱한 답을 하기도 하고, 복잡한 요청에 조용해지기도 하고, API 호출이 실패하면 멘붕하기도 한다. 그래도 매일 조금씩 나아진다. 스킬이 쌓이고, 온톨로지가 두꺼워지고, 내가 자비스를 이해하고 자비스가 나를 이해하는 만큼.

아이언맨의 자비스가 토니 스타크의 "확장된 지능"이었던 것처럼, 내 자비스도 점점 그 방향으로 가고 있다고 느낀다. 아직 슈트는 못 만들지만. (거기까지는... 좀 더 걸릴 것 같다.)

| 배운 것 | 액션 아이템 |
|---------|------------|
| AI 에이전트는 "질문-답변"이 아니라 "위임-실행"이다 | OpenClaw 설치하고 SOUL.md 하나 써보기 |
| 도구는 분산시키되, 통합은 AI에게 맡겨라 | 자주 쓰는 도구 3개 연동해보기 |
| 온톨로지가 AI의 답변 품질을 결정한다 | 옵시디언에 태그 체계 하나만 정해서 시작하기 |
| 크론잡은 "시간을 버는" 게 아니라 "인지 부하를 없애는" 것이다 | 매일 반복하는 확인 작업 하나를 크론으로 만들기 |

다시 한번 다짐하게 된다. 이건 시작일 뿐이다.

OpenClaw를 설치하고, SOUL.md 하나만 써보는 것부터 시작해봐라. "나는 누구이고, 이 AI에게 뭘 원하는지" — 그걸 정의하는 순간부터 달라진다. 거창하게 10개 크론을 다 세팅할 필요 없다. 하나만. 아침 브리핑 하나만 걸어봐라.

그 하나가 열 개가 되고, 열 개가 시스템이 되는 건 시간문제다.

> "There is no reason and no way that a human mind can keep up with an artificial intelligence machine by 2035."
> "인간의 지능이 2035년까지 인공지능을 따라잡을 수 있는 이유도, 방법도 없다."
>
> — Gray Scott

따라잡을 수 없다면, 함께 가면 된다.

---

## References

- [OpenClaw](https://openclaw.ai) — AI 에이전트 프레임워크
- [OpenClaw Docs](https://docs.openclaw.ai) — 공식 문서
- [OpenClaw GitHub](https://github.com/openclaw/openclaw) — 소스 코드
- [Obsidian](https://obsidian.md) — 로컬 마크다운 노트 앱
- [Scrumble 기술 회고](https://flowkater.io/posts/2025-09-scrumble-tech-retro-backend/) — Scrumble 개발기
